# 如何监听合约事件

## 技术栈

- **Etherscan API**: 区块链浏览器提供的 API 服务
  - `getLogs`: 获取合约的事件日志
  - 支持 topic 过滤、区块范围过滤、分页
- **Viem**: 以太坊工具库
  - `decodeEventLog`: 解析事件日志的原始数据为可读格式
  - `toEventSignature`: 计算事件签名的 keccak256 哈希

## 实现概览

- 用 **fetch** 调用 Etherscan API 的 `getLogs` 接口，获取合约触发的事件日志
- 用 **Viem** 的 `toEventSignature` 计算事件签名哈希（topic0），用于过滤特定类型的事件
- 用 **Viem** 的 `decodeEventLog` 解析事件日志的 topics 和 data，提取出可读的参数值

## 核心概念

### 什么是智能合约事件（Event）？

事件是智能合约与外部世界通信的方式。当合约执行某些操作时（如转账、授权），会触发事件并记录在区块链上。

```solidity
// Solidity 中的事件定义
event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed owner, address indexed spender, uint256 value);
```

### 事件 vs 交易

| 特点 | 交易（Transaction） | 事件（Event） |
|------|---------------------|---------------|
| 发起者 | 用户/钱包 | 智能合约 |
| 内容 | from、to、value、gas 等 | 合约定义的参数 |
| 数量关系 | 一笔交易 | 可能触发多个事件 |
| 用途 | 记录操作行为 | 记录操作结果/状态变化 |

例如：一笔 Uniswap 交易可能触发多个 Transfer 事件（支付代币、收到代币、手续费等）。

### 事件日志的结构

事件日志存储在区块链上，包含以下关键字段：

| 字段 | 说明 |
|------|------|
| `topics[0]` | 事件签名的 keccak256 哈希，用于识别事件类型 |
| `topics[1-3]` | indexed 参数的值（最多 3 个） |
| `data` | 非 indexed 参数的 ABI 编码数据 |
| `transactionHash` | 触发该事件的交易哈希 |
| `blockNumber` | 事件所在区块号 |
| `timeStamp` | 事件时间戳 |

### indexed 参数的作用

- **indexed 参数**：存储在 topics 中，可以被高效检索和过滤
- **非 indexed 参数**：存储在 data 中，需要 ABI 解码才能读取

```solidity
// Transfer 事件中，from 和 to 是 indexed，可以按发送方/接收方过滤
event Transfer(
    address indexed from,    // topics[1]
    address indexed to,      // topics[2]
    uint256 value           // data 中
);
```

### USDT 合约支持的事件

| 事件名 | 说明 | 发生频率 |
|--------|------|----------|
| Transfer | 代币转账 | 最高频（每秒大量发生） |
| Approval | 授权操作 | 高频 |
| Issue | Tether 公司增发 USDT | 中频 |
| Redeem | Tether 公司赎回 USDT | 中频 |
| AddedBlackList | 添加地址到黑名单 | 低频 |
| RemovedBlackList | 从黑名单移除地址 | 低频 |
| DestroyedBlackFunds | 销毁黑名单地址的资金 | 低频 |
| Pause / Unpause | 暂停/恢复合约 | 极少 |

## 核心实现详情

### 1. 定义事件 ABI

调用 `decodeEventLog` 前，需要知道事件的 ABI 定义：

```typescript
// USDT 合约的 Transfer 和 Approval 事件 ABI
const USDT_EVENT_ABI = [
  {
    anonymous: false,
    inputs: [
      { indexed: true, name: "from", type: "address" },   // topics[1]
      { indexed: true, name: "to", type: "address" },     // topics[2]
      { indexed: false, name: "value", type: "uint256" }, // data 中
    ],
    name: "Transfer",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, name: "owner", type: "address" },
      { indexed: true, name: "spender", type: "address" },
      { indexed: false, name: "value", type: "uint256" },
    ],
    name: "Approval",
    type: "event",
  },
] as const;
```

### 2. 计算事件签名（topic0）

要过滤特定类型的事件，需要计算事件签名的 keccak256 哈希：

```typescript
import { toEventSignature, keccak256, toBytes } from "viem";

// 方法 1：使用 toEventSignature（推荐）
const transferSignature = toEventSignature(
  "Transfer(address,address,uint256)"
);
// 返回: "Transfer(address indexed from, address indexed to, uint256 value)"

// 方法 2：直接计算 keccak256 哈希
const topic0 = keccak256(toBytes("Transfer(address,address,uint256)"));
// 返回: "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"

// 这个 topic0 可以用来过滤只查询 Transfer 事件
```

### 3. 调用 Etherscan API 获取事件日志

```typescript
// 构建 API 请求 URL
const params = new URLSearchParams({
  chainid: "1",                    // 以太坊主网
  module: "logs",                  // logs 模块提供事件日志查询
  action: "getLogs",               // getLogs 接口
  address: usdtContractAddress,    // 合约地址
  fromBlock: "21234500",           // 起始区块（建议回退 12 个区块）
  toBlock: "latest",               // 结束区块
  page: "1",                       // 分页页码
  offset: "10",                    // 每页记录数
  // topic0: "0xddf252...",        // 可选，过滤特定事件类型
  apikey: "YOUR_API_KEY",
});

const response = await fetch(
  `https://api.etherscan.io/v2/api?${params.toString()}`
);
const result = await response.json();

// 返回数据结构：
// {
//   "status": "1",
//   "message": "OK",
//   "result": [
//     {
//       "address": "0xdac17f958d2ee523a2206206994597c13d831ec7",
//       "topics": [
//         "0xddf252ad...",  // topic0: 事件签名哈希
//         "0x000000...123", // topic1: from 地址（补齐 32 字节）
//         "0x000000...456"  // topic2: to 地址（补齐 32 字节）
//       ],
//       "data": "0x0000000000000000000000000000000000000000000000000000000005f5e100",
//       "blockNumber": "0x141b8a0",
//       "timeStamp": "0x65767890",
//       "transactionHash": "0x...",
//       "logIndex": "0x1"
//     },
//     ...
//   ]
// }
```

### 4. 解析事件日志

使用 Viem 的 `decodeEventLog` 解析原始数据：

```typescript
import { decodeEventLog } from "viem";

// 解析单个事件日志
function parseEventLog(log: EventLog, eventAbi: readonly EventAbiItem[]) {
  // 使用 Viem 解析事件
  const decoded = decodeEventLog({
    abi: eventAbi,
    data: log.data as `0x${string}`,
    topics: log.topics as [`0x${string}`, ...`0x${string}`[]],
    strict: false, // 允许部分解码
  });

  // decoded 结构：
  // {
  //   eventName: "Transfer",
  //   args: {
  //     from: "0x123...",    // 发送方地址
  //     to: "0x456...",      // 接收方地址
  //     value: 100000000n    // 金额（BigInt 类型）
  //   }
  // }

  return {
    eventName: decoded.eventName,
    params: {
      from: decoded.args.from,
      to: decoded.args.to,
      value: decoded.args.value.toString(), // BigInt 转字符串
    },
    transactionHash: log.transactionHash,
    blockNumber: log.blockNumber,
    timeStamp: log.timeStamp,
  };
}
```

### 5. 处理数据延迟问题

最新区块的数据可能还未被 Etherscan 同步，建议回退一定区块数：

```typescript
// 安全确认区块数（12 个区块约 2.4 分钟）
const SAFE_CONFIRMATIONS = 12;

// 获取安全的起始区块
async function getSafeFromBlock(chainId: number): Promise<number> {
  // 获取当前区块号
  const params = new URLSearchParams({
    chainid: chainId.toString(),
    module: "proxy",
    action: "eth_blockNumber",
    apikey: "YOUR_API_KEY",
  });
  
  const response = await fetch(
    `https://api.etherscan.io/v2/api?${params.toString()}`
  );
  const result = await response.json();
  
  // 返回十六进制，需要转换
  const currentBlock = parseInt(result.result, 16);
  
  // 回退 12 个区块
  return Math.max(0, currentBlock - SAFE_CONFIRMATIONS);
}
```

## 常见问题

### 为什么查询最新区块返回空数据？

Etherscan 的数据同步有延迟，最新区块的事件可能还未被索引。解决方案：

1. 使用 `fromBlock` 回退 12 个区块
2. 在 UI 中提示用户数据有 2-3 分钟延迟

### indexed 参数最多只能有 3 个？

是的，这是 EVM 的限制。topics 数组最多 4 个元素：
- topics[0]：事件签名
- topics[1-3]：最多 3 个 indexed 参数

### 如何过滤特定发送方/接收方的事件？

可以使用 topic1、topic2 参数过滤：

```typescript
const params = new URLSearchParams({
  module: "logs",
  action: "getLogs",
  address: contractAddress,
  topic0: "0xddf252ad...",  // Transfer 事件签名
  topic1: "0x000...sender", // 过滤发送方（需要补齐到 32 字节）
  // topic2: "0x000...receiver", // 或过滤接收方
});
```

### 事件和交易查询有什么区别？

- **tokentx**：返回代币转账记录，每条记录对应一次 transfer 调用
- **getLogs**：返回合约触发的所有事件，包括 Transfer、Approval 等

使用场景：
- 想看代币交易历史 → 用 tokentx
- 想监控合约所有活动（包括授权、增发等）→ 用 getLogs
