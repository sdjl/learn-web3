# 如何查询合约信息

## 技术栈

- **Viem**: 以太坊工具库，提供 `createPublicClient`、`getCode`、`getBalance`、`formatEther`、`isAddress`、`readContract` 等函数
- **Etherscan API V2**: 区块链浏览器 API，提供统一的合约源代码和 ABI 查询接口

## 实现概览

- 用 **Viem** 的 `createPublicClient` 创建公共客户端连接区块链网络
- 用 **Viem** 的 `getCode` 获取合约字节码，判断地址是否为智能合约
- 用 **Viem** 的 `getBalance` 获取合约余额
- 用 **Viem** 的 `formatEther` 函数将 BigInt 类型的 wei 转换为可读的 ETH 字符串
- 用 **Viem** 的 `isAddress` 函数验证地址格式
- 用 **Next.js Server Action** 在服务端安全调用 Etherscan API，避免在客户端暴露 API Key
- 用 **Etherscan API V2** 的 `getsourcecode` 接口获取合约源代码、合约名称、编译器版本、ABI 等信息

## 核心实现详情

### 1. 创建 Server Action 获取合约信息

```typescript
"use server";

import { createPublicClient, http, isAddress, formatEther } from "viem";
import { mainnet, sepolia } from "viem/chains";

/**
 * 获取合约信息
 * 
 * @param params.address - 合约地址（0x 开头的 42 位十六进制字符串）
 * @param params.chainId - 链 ID（1 表示主网，11155111 表示 Sepolia 测试网）
 * @param params.rpcUrl - RPC 节点 URL
 * 
 * @returns 返回合约信息对象或错误对象
 * - `address`: string - 合约地址
 * - `isContract`: boolean - 是否为智能合约地址
 * - `bytecode`: string | undefined - 合约字节码
 * - `balance`: bigint - 地址余额（wei）
 * - `balanceFormatted`: string - 格式化后的余额（ETH）
 * - `sourceCode`: string | undefined - 合约源代码
 * - `contractName`: string | undefined - 合约名称
 * - `compilerVersion`: string | undefined - 编译器版本
 * - `optimizationUsed`: boolean | undefined - 是否启用优化编译
 * 失败时返回 `{ error: string }`
 */
export async function getContractInfo(params: {
  address: string;
  chainId: number;
  rpcUrl: string;
}) {
  // 验证地址格式
  if (!isAddress(params.address)) {
    return { error: "无效的地址格式" };
  }

  // 根据链 ID 选择链配置
  const chain = params.chainId === 11155111 ? sepolia : mainnet;

  // 创建公共客户端，用于与区块链交互
  // client 提供了丰富的区块链交互功能，详见下方"createPublicClient 返回的 client 常用功能"部分
  const client = createPublicClient({
    chain,
    transport: http(params.rpcUrl),
  });

  // 获取合约字节码，用于判断是否为合约地址
  const bytecode = await client.getCode({
    address: params.address as `0x${string}`,
  });

  // 获取合约余额（以 wei 为单位）
  const balance = await client.getBalance({
    address: params.address as `0x${string}`,
  });

  // 判断是否为合约（有字节码且不为空）
  const isContract = Boolean(bytecode && bytecode !== "0x");

  // 格式化余额：将 wei 转换为 ETH 字符串
  const balanceFormatted = formatEther(balance);

  // 基础合约信息
  const contractInfo = {
    address: params.address,
    isContract,
    bytecode: bytecode || undefined,
    balance,
    balanceFormatted,
  };

  // 如果是合约，尝试从 Etherscan 获取源代码
  if (isContract) {
    const sourceInfo = await getContractSourceCode(
      params.address,
      params.chainId
    );
    Object.assign(contractInfo, sourceInfo);
  }

  return contractInfo;
}
```

### 2. createPublicClient 返回的 client 常用功能

`createPublicClient` 创建的 `client` 对象提供了丰富的区块链交互功能，以下是常用接口：

#### 账户和余额相关

```typescript
// 获取地址余额（返回 BigInt，单位为 wei）
const balance = await client.getBalance({
  address: "0x..." as `0x${string}`,
});

// 获取地址的 nonce（交易计数）
const nonce = await client.getTransactionCount({
  address: "0x..." as `0x${string}`,
});
```

#### 合约相关

```typescript
// 获取合约字节码
const bytecode = await client.getCode({
  address: "0x..." as `0x${string}`,
});

// 读取合约数据（调用 view/pure 函数，不发送交易）
const result = await client.readContract({
  address: "0x..." as `0x${string}`,
  abi: contractABI,
  functionName: "balanceOf",
  args: ["0x..."],
});

// 执行合约调用（不发送交易，用于测试）
const result = await client.call({
  to: "0x..." as `0x${string}`,
  data: "0x...",
});

// 估算交易的 gas 消耗
const gas = await client.estimateGas({
  to: "0x..." as `0x${string}`,
  value: parseEther("1"),
});
```

#### 交易相关

```typescript
// 获取交易详情
const tx = await client.getTransaction({
  hash: "0x..." as `0x${string}`,
});

// 获取交易收据（包含执行结果）
const receipt = await client.getTransactionReceipt({
  hash: "0x..." as `0x${string}`,
});

// 等待交易确认（轮询直到交易被确认）
const receipt = await client.waitForTransactionReceipt({
  hash: "0x..." as `0x${string}`,
});
```

#### 区块相关

```typescript
// 获取区块信息
const block = await client.getBlock({
  blockNumber: 12345678n,
});

// 获取当前区块号
const blockNumber = await client.getBlockNumber();

// 获取区块的哈希值
const blockHash = await client.getBlockHash({
  blockNumber: 12345678n,
});
```

#### 其他常用功能

```typescript
// 获取链 ID
const chainId = await client.getChainId();

// 获取 gas 价格
const gasPrice = await client.getGasPrice();

// 获取网络信息
const network = await client.getNetwork();
```

### 3. 从 Etherscan API 获取合约源代码

```typescript
/**
 * 从 Etherscan API 获取合约源代码
 * 
 * 注意：Etherscan API V2 需要 API Key 才能获取源代码，如果没有设置 API Key，函数会返回空对象。
 * 
 * @param address - 合约地址
 * @param chainId - 链 ID（1 表示主网，11155111 表示 Sepolia 测试网）
 * 
 * @returns 返回包含合约源代码信息的对象，所有字段都是可选的
 * - `sourceCode`: string | undefined - 合约源代码（单文件或多文件合并后的字符串）
 * - `contractName`: string | undefined - 合约名称
 * - `compilerVersion`: string | undefined - 编译器版本
 * - `optimizationUsed`: boolean | undefined - 是否启用优化编译
 * 如果获取失败或合约未验证，返回空对象 `{}`
 */
async function getContractSourceCode(
  address: string,
  chainId: number
): Promise<{
  sourceCode?: string;
  contractName?: string;
  compilerVersion?: string;
  optimizationUsed?: boolean;
}> {
  // 构建 Etherscan API V2 请求 URL
  // V2 API 使用统一的端点，通过 chainid 参数指定链
  const apiUrl = `https://api.etherscan.io/v2/api?chainid=${chainId}&module=contract&action=getsourcecode&address=${address}`;
  
  const response = await fetch(apiUrl);
  const data = await response.json();

  if (data.status === "1" && data.result && data.result.length > 0) {
    const result = data.result[0];

    // 处理源代码：可能是字符串或 JSON 字符串（多文件合约）
    let sourceCode: string | undefined;
    if (result.SourceCode && result.SourceCode.trim() !== "") {
      // 检查是否是 JSON 字符串（多文件合约）
      if (result.SourceCode.startsWith("{{") || result.SourceCode.startsWith("{")) {
        // 解析 JSON 并提取所有文件内容
        const parsed = JSON.parse(result.SourceCode);
        // 提取所有源代码文件内容
        sourceCode = extractSources(parsed);
      } else {
        sourceCode = result.SourceCode;
      }
    }

    return {
      sourceCode,
      contractName: result.ContractName || undefined,
      compilerVersion: result.CompilerVersion || undefined,
      optimizationUsed: result.OptimizationUsed === "1",
    };
  }

  return {};
}
```

### 4. 查询合约状态变量

合约的状态变量（如 USDT 合约的 `basisPointsRate` 手续费率）可以通过调用合约的无参数 `view` 函数来读取。

#### 原理说明

Solidity 合约中的 `public` 状态变量会自动生成一个同名的 getter 函数。例如：

```solidity
// Solidity 合约
contract TetherToken {
    uint public basisPointsRate = 0;      // 手续费基点（0.0001% 为 1 基点）
    uint public maximumFee = 0;           // 最大手续费
    address public owner;                  // 合约所有者
    string public name;                    // 代币名称
    string public symbol;                  // 代币符号
    uint8 public decimals;                 // 小数位数
    uint public _totalSupply;             // 总供应量
}
```

这些 `public` 变量会自动生成以下 `view` 函数：

```solidity
function basisPointsRate() public view returns (uint);
function maximumFee() public view returns (uint);
function owner() public view returns (address);
function name() public view returns (string);
// ... 以此类推
```

#### 实现步骤

1. **获取合约 ABI**：从 Etherscan API 的 `getsourcecode` 接口获取，响应中包含 `ABI` 字段
2. **筛选可读函数**：从 ABI 中筛选出无参数的 `view` 或 `pure` 函数
3. **调用函数读取值**：使用 Viem 的 `readContract` 方法调用这些函数

#### 代码实现

```typescript
import { createPublicClient, http, formatUnits } from "viem";

/**
 * 获取合约的状态变量值
 * 
 * @param params.address - 合约地址
 * @param params.chainId - 链 ID
 * @param params.rpcUrl - RPC URL
 * @param params.abi - 合约 ABI
 * 
 * @returns 状态变量列表
 */
async function getContractStateVariables(params: {
  address: string;
  chainId: number;
  rpcUrl: string;
  abi: AbiFunction[];
}): Promise<StateVariable[]> {
  // 创建公共客户端
  const client = createPublicClient({
    chain: getChainById(params.chainId),
    transport: http(params.rpcUrl),
  });

  // 从 ABI 中筛选出可以读取的状态变量（无参数的 view/pure 函数）
  const readableFunctions = params.abi.filter(
    (item) =>
      item.type === "function" &&
      (item.stateMutability === "view" || item.stateMutability === "pure") &&
      (!item.inputs || item.inputs.length === 0) &&
      item.outputs &&
      item.outputs.length > 0
  );

  // 并发调用所有可读函数
  const results = await Promise.allSettled(
    readableFunctions.map(async (func) => {
      const result = await client.readContract({
        address: params.address as `0x${string}`,
        abi: [func],
        functionName: func.name!,
      });

      return {
        name: func.name!,
        type: func.outputs![0].type,
        value: formatVariableValue(result), // 格式化状态变量的值
        rawValue: result,
      };
    })
  );

  // 收集成功的结果
  const variables: StateVariable[] = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      variables.push(result.value);
    }
  }

  return variables;
}
```
